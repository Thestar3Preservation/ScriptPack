#!/bin/bash
#====================================================================================
#아래 영상과 자막에 맞춰 만들어짐.
#test.mkv
#내장 영어 자막.ass
#번역된 가사를 싱크가 자막 파일의 맞춰진 내용대로 매칭시키고, 번역된 내용을 자막의 외국어와 교체시킴.
#====================================================================================
:<<\EOF
 작업 결과 예시 창에 뜬 결과가 1,2,1,2,1,2식의 순서라면, 실제결과는 2,1,2,1,2,1식의 순서이다. 또한 결과를 확인할때, 대각선으로 봐야 한다. 자막 1,2 번역 1,2 짝맞춤 1-2,2-1.
 자막과 번역파일의 위치는 스크립트가 위치한 곳과 다른곳이라도 상관없다. 결과물은 스크립트가 위치한 곳에 저장된다. 이떄, 이 위치에 같은 이름의 파일이 존재할 경우 해당 파일은 삭제된다.
 첫번째 인수, 번역가사파일. 두번쨰 인수, 자막파일. 세번째 인수, 번역가사의 자막파일에서의 시작위치. 네번째 인수, 번역가사파일의 음역제거 여부(y또는 n). 다섯번째 인수, 번역된 제목.
 윈도우식의 줄바꿈을 무시함. Mac용 없음. 리눅스용 기본. 윈도우와 리눅스식 줄바꿈된 파일만 정상적용됨.
 번역가사 파일에서 공백줄은 무시된다. 원어, 음역, 번역가사 또는 원어, 번역가사 형식으로 짜여있어야 한다.
 번역 제목이 공백이면 원제목을 그대로 쓰고, 'n'일시 해당 위치 부터 가사로 취급한다.
EOF
# 번역가사파일의 원어의 띄어쓰기여부(y또는 n). 여섯번째 인수,
#====================================================================================
:<<\EOF
 {\an8} 로 표시된 영어 음역을 원어로 대치시키고, 그 위에 있는 영어 번역 가사를 한글 번역 가사로 대치시킨다. 두 개의 자막의 위치를 교체시킨다. 또는, 표시된 두 영역을 서로 바꾸어 기록한다. 영어 음역에 한글 번역 가사로, 영어 번역 가사에 원어가 위치하도록 대치시킨다. --> 후자의 방법을 사용할 경우, 저장할때, {\an8}가 위치할 영역만 바꾸면 된다. 그러나, 이 방법은 ass 함수를 사용하지 않을 경우(즉, smi방식으로 출력될 경우), 번역 가사, 원어식으로 뜨기 떄문에 보기에 안좋다. 따라서 전자의 방법을 사용해야 한다.
 한글 번역 가사+원어 파일은 모든 공백줄과 각 행의 앞뒤 공백을 제거하여야 한다.
 한글 번역 가사+원어 파일에 한글 음역이 포함되었을 경우, 제거한다. 우리가 만드는건 개인용이므로 변수를 포함시키지 않는다(대부분 영어,한글 음역,번역 가사의 순서로 이뤄져있어서 변수의 포함이 없어도 대부분 잘 처리된다).
 원본 가사 파일과 한글 번역 가사+원어 파일은 모두 UTF-8의 캐릭셋으로 불러와져야 한다. 저장 결과 역시 마찬가지이다.
 작업의 완성도를 높이고, 오작업률을 낮추기 위해 작업전 사용자에게 사전 확인을 시키킨다. 만약 잘못되었을시, 작업을 종료시킨다. --> 있는 그대로 보여주도록 한다. 어차피 제작자가 사용자이므로, 작업 결과 예시 창의 정보가 무엇을 의미하는지 안다. 사용자 이해도를 높이기 위해 불필요한 과정을 추가시키지 않아도 된다.
 한번의 작업으로 끝나는게 아니므로, 여러번 작업 할수 있도록 사용자 대화 인터페이스를 적용시킨다(단순히 변수 입력을 보기 쉽게 만들고, 추가작업을 사용자에게 묻는 정도).
EOF
#====================================================================================
source ~/.bash_profile
LOAD_USER_FUNTION

home=$(dirname "$0")
cd "$home"
echo "작업공간의 현재위치 : $home"
[ "$1" ] && t1=$1 || read -p '번역된 가사 파일의 경로는? ' t1
t1=`echo "$t1" | sed -r -e "s/'\s*$//" -e "s/^\s*'//"`
check=`nkf -g "$t1"`
[ "$check" = UTF-8 ] && t1f=`cat "$t1"` || t1f=`iconv -f=$check -t=utf-8 "$t1"`
t1f=`echo "$t1f" | sed -r -e '/^\s*$/d' -e 's/^\s+//' -e 's/\s+$//' | tr -d '\r'`
[ "$4" ] && o1=$4 || read -p '번역된 가사 파일에 음역이 두번째(전체 세줄에서) 줄마다 있는가?(y/n) ' o1
case $o1 in
	[yY][eE][sS] | [yY]*)
		echo "음역을 제거함."
		for ((i=2; i<=`echo "$t1f" | wc -l`; i=i+3)); do ddhqtus="$ddhqtus -e ${i}d"; done
		t1f=`echo "$t1f" | eval "sed $ddhqtus"`;;
	*)
		echo "음역 제거 없음.";;
esac
unset ddhqtus
for ((i=1; i<=`echo "$t1f" | wc -l`; i=i+2)); do
	ddhqtus="$ddhqtus
`echo "$t1f" | sed -n -e 's/ //g' -e 's/　//g' -e ${i}p`
`echo "$t1f" | sed -n $((i+1))p`"
done
t1f=$( echo "$ddhqtus" | sed 1d )
:<<\EOF
[ "$5" ] && o2=$5 || read -p '번역된 가사 파일에 원어가 띄어쓰기되어 있는가?(y/n) ' o2
case $o1 in
	[yY][eE][sS] | [yY]*)
		echo "원어의 띄어쓰기를 제거함."
		for ((i=1; i<=`echo "$t1f" | wc -l`; i=i+3)); do t1f=$(echo "$t1f" | sed -e ${i}p -e 's/ //g' -e 's/　//g'); done;;
	*) echo "띄어쓰기 제거 없음.";;
esac
EOF
[ "$2" ] && t2=$2 || read -p '수정될 자막 파일의 경로는? ' t2
t2=`echo "$t2" | sed -e "s/'\s*$//" -e "s/^\s*'//"`
check=`nkf -g "$t2"`
[ "$check" = UTF-8 ] && t2f=`cat "$t2" | tr -d '\r'` || t2f=`iconv -f=$check -t=utf-8 "$t2" | tr -d '\r'`
[ "$3" ] && st=$3 || read -p '시작지점(가사의 제목이 위치하는 행)은? ' st
n1=$(echo "$t2f" | sed -n ${st}p | sed -e 's/^\(.*0000,0000,0000,,[{]\\fad[(]2000,2000[)][}][{]\\an7[}][0-9][0-9]\. \).*$/\1/I' -e 's/^\(.*0000,0000,0000,,[{]\\an7[}][{]\\fad[(]2000,2000[)][}][0-9][0-9]\. \).*$/\1/I')
n2o=$(echo "$t2f" | sed -n ${st}p | sed 's/^.*[}][0-9][0-9]\. //')
if [ "$5" ]; then
	n2=$5
else
	echo "원문 제목 : $n2o"
	read -p "번역된 제목은? " n2
fi
[ -z "$n2" ] && { echo '제목을 변경하지 않습니다.'; n2=$n2o; }
if [ "$n2" = n ]
then
	echo '제목 설정을 무시하고, 해당 위치 부터 짝맞춤을 실행합니다.'
	check_1=$st
else
	check_1=$((st+1))
fi
check=0
echo '짝맞는 부분을 찾아내어 기억하는중...'$'\n''확인 목록을 만들어 내는 중...'
for i in $t1f; do
	a1b[$check]=$(echo "$t2f" | sed -n "${check_1}p" | sed -r 's/^(.*0000,0000,0000,,(.*[}]){0,1}).*$/\1/I')
	a2=$(echo "$t2f" | sed -n "${check_1}p" | sed -r 's/^.*0000,0000,0000,,(.*[}]){0,1}//I')
	a2b[$check]=$i
	list="$list \"`echo "$a2" | sed -e 's/"/\\\\"/g' -e 's/!/\\!/g'`\" \"`echo "$i" | sed -e 's/"/\\\\"/g' -e 's/!/\\!/g'`\""
	((check_1++))
	((check++))
done
echo '확인 목록을 띄우고, 작업 진행 의사를 물음.'
if eval "zenity --list --title '자막과 번역된 가사의 짝맞춤 확인' --text '아래 목록에서 올바른 짝맞춤이 이뤄졌는지 확인한뒤 올바를시 확인을 누르고, 아닐시 취소를 누르시오.' --width 900 --height 700 --column 자막 --column '번역된 가사' $list"; then
	echo '파일의 내용이 올바름을 확인'
	ed=`echo "$t1f" | wc -l`
	for ((i=0; i<ed; i=i+2)); do
		data="$data
${a1b[$(($i+1))]}${a2b[$i]}
${a1b[$i]}${a2b[$(($i+1))]}"
	done
	((ed=ed+st))
	st2=`basename "$t2"`
	echo '변경된 내용의 파일로 갱신함'
	trash-put "$t2"
	data=`echo "$data" | sed '/^\s*$/d'`
	if [ "$n2" = n ]; then
		echo "$(echo "$t2f" | sed -n 1,$((st-1))p)
$data
$(echo "$t2f" | sed -n $ed,\$p)" > "$st2"
	else
		echo "$(echo "$t2f" | sed -n 1,$((st-1))p)
${n1}${n2}
$data
$(echo "$t2f" | sed -n $((ed+1)),\$p)" > "$st2"
	fi
else
	echo '작업이 취소되었습니다.'
	read -n1 -rsp 'n키를 눌러 작업을 재시도하거나 아무키나 눌러 현재창을 닫습니다...'
	echo
	case $REPLY in
		[Nn])
			echo -e "프로세서를 재시작함.\n\n"
			exec bash "$0" "$t1" "$t2" "$st" "$o1" "$n2";; # "$o2"
		*)
			exit;;
	esac
fi
pause
exit